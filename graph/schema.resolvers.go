package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"log"

	model1 "github.com/openbrighton/graphql-service/graph/model"
)

// SubmitContact is the resolver for the submitContact field.
func (r *mutationResolver) SubmitContact(ctx context.Context, input model1.SubmitContactInput) (bool, error) {
	templateData := `{"name": "` + input.Name + `", "email": "` + input.Email + `", "message": "` + input.Message + `"}`
	err := SendEmail(ctx, CONTACT_EMAIL, NO_REPLY_EMAIL, "contact", templateData)
	if err != nil {
		log.Printf("failed to send email: %v", err)
		return false, err
	}
	return true, nil
}

// SubmitFeedback is the resolver for the submitFeedback field.
func (r *mutationResolver) SubmitFeedback(ctx context.Context, input model1.SubmitFeedbackInput) (bool, error) {
	templateData := `{"email": "` + input.Email + `", "category": "` + input.Category + `", "message": "` + input.Message + `"}`
	err := SendEmail(ctx, CONTACT_EMAIL, NO_REPLY_EMAIL, "feedback", templateData)
	if err != nil {
		log.Printf("failed to send email: %v", err)
		return false, err
	}
	return true, nil
}

// CreateDonatePaymentIntent is the resolver for the createDonatePaymentIntent field.
func (r *mutationResolver) CreateDonatePaymentIntent(ctx context.Context, input model1.CreateDonatePaymentIntentInput) (*model1.PaymentIntentResult, error) {
	return &model1.PaymentIntentResult{ClientSecret: "stub_pi_secret"}, nil
}

// CreateDonateSubscription is the resolver for the createDonateSubscription field.
func (r *mutationResolver) CreateDonateSubscription(ctx context.Context, input model1.CreateDonateSubscriptionInput) (*model1.PaymentIntentResult, error) {
	return &model1.PaymentIntentResult{ClientSecret: "stub_sub_secret"}, nil
}

// Chat is the resolver for the chat field.
func (r *mutationResolver) Chat(ctx context.Context, input model1.ChatInput) (string, error) {
	return CallClaude(ctx, input.Messages)
}

// Whoami is the resolver for the whoami field.
func (r *queryResolver) Whoami(ctx context.Context) (*model1.User, error) {
	return nil, nil
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, first *int32, after *string, category []model1.FeedItemCategory) (*model1.FeedItemConnection, error) {
	items := stubFeedItems
	if len(category) > 0 {
		allowed := make(map[model1.FeedItemCategory]bool, len(category))
		for _, c := range category {
			allowed[c] = true
		}
		filtered := items[:0]
		for _, item := range items {
			if allowed[item.Category] {
				filtered = append(filtered, item)
			}
		}
		items = filtered
	}

	start := startIndex(after)
	size := pageSize(first, len(items)-start)
	if start > len(items) {
		start = len(items)
	}
	end := start + size
	if end > len(items) {
		end = len(items)
	}

	slice := items[start:end]
	edges := make([]*model1.FeedItemEdge, len(slice))
	for i, item := range slice {
		c := encodeCursor(start + i)
		edges[i] = &model1.FeedItemEdge{Cursor: c, Node: item}
	}

	var startCursor, endCursor *string
	hasNext := end < len(items)
	hasPrev := start > 0
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}

	return &model1.FeedItemConnection{
		Edges: edges,
		PageInfo: &model1.PageInfo{
			HasNextPage:     hasNext,
			HasPreviousPage: hasPrev,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, first *int32, after *string, category []model1.EventCategory) (*model1.EventConnection, error) {
	items := stubEvents
	if len(category) > 0 {
		allowed := make(map[model1.EventCategory]bool, len(category))
		for _, c := range category {
			allowed[c] = true
		}
		filtered := items[:0]
		for _, item := range items {
			if allowed[item.Category] {
				filtered = append(filtered, item)
			}
		}
		items = filtered
	}

	start := startIndex(after)
	size := pageSize(first, len(items)-start)
	if start > len(items) {
		start = len(items)
	}
	end := start + size
	if end > len(items) {
		end = len(items)
	}

	slice := items[start:end]
	edges := make([]*model1.EventEdge, len(slice))
	for i, item := range slice {
		c := encodeCursor(start + i)
		edges[i] = &model1.EventEdge{Cursor: c, Node: item}
	}

	var startCursor, endCursor *string
	hasNext := end < len(items)
	hasPrev := start > 0
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}

	return &model1.EventConnection{
		Edges: edges,
		PageInfo: &model1.PageInfo{
			HasNextPage:     hasNext,
			HasPreviousPage: hasPrev,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

// Businesses is the resolver for the businesses field.
func (r *queryResolver) Businesses(ctx context.Context, first *int32, after *string, category []model1.BusinessCategory) (*model1.BusinessConnection, error) {
	items := stubBusinesses
	if len(category) > 0 {
		allowed := make(map[model1.BusinessCategory]bool, len(category))
		for _, c := range category {
			allowed[c] = true
		}
		filtered := items[:0]
		for _, item := range items {
			if allowed[item.Category] {
				filtered = append(filtered, item)
			}
		}
		items = filtered
	}

	start := startIndex(after)
	size := pageSize(first, len(items)-start)
	if start > len(items) {
		start = len(items)
	}
	end := start + size
	if end > len(items) {
		end = len(items)
	}

	slice := items[start:end]
	edges := make([]*model1.BusinessEdge, len(slice))
	for i, item := range slice {
		c := encodeCursor(start + i)
		edges[i] = &model1.BusinessEdge{Cursor: c, Node: item}
	}

	var startCursor, endCursor *string
	hasNext := end < len(items)
	hasPrev := start > 0
	if len(edges) > 0 {
		sc := edges[0].Cursor
		ec := edges[len(edges)-1].Cursor
		startCursor = &sc
		endCursor = &ec
	}

	return &model1.BusinessConnection{
		Edges: edges,
		PageInfo: &model1.PageInfo{
			HasNextPage:     hasNext,
			HasPreviousPage: hasPrev,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}, nil
}

// Business is the resolver for the business field.
func (r *queryResolver) Business(ctx context.Context, slug string) (*model1.Business, error) {
	for _, b := range stubBusinesses {
		if b.Slug == slug {
			return b, nil
		}
	}
	return nil, nil
}

// ValidateAddress is the resolver for the validateAddress field.
// It checks whether the provided address is a valid Brighton address.
func (r *queryResolver) ValidateAddress(ctx context.Context, address string) (*model1.AddressValidation, error) {
	if address == "" {
		msg := "Please enter an address."
		return &model1.AddressValidation{Valid: false, Message: &msg}, nil
	}
	// TODO: integrate a real address validation service (e.g. USPS, Google Maps, or a Brighton-specific dataset).
	normalised := address
	return &model1.AddressValidation{Valid: true, NormalizedAddress: &normalised}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
